<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>遊戲回放</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { background-color: #000; display: flex; flex-direction: column; align-items: center; color: white; font-family: "微軟正黑體", sans-serif; margin: 0; }
    canvas { background-color: #111; border: 3px solid #fff; margin-top: 10px; }
    #replay-status { margin: 10px; }
    #controls { margin-top: 10px; display: flex; gap: 10px; align-items: center; }
    .btn { background: #444; color: white; padding: 10px 20px; border-radius: 10px; font-size: 16px; user-select: none; cursor: pointer; }
    .btn:active { background: #777; }
    #progress-slider { width: 400px; margin-top: 15px; cursor: pointer; }
    #back-link { color: #6cf; margin-top: 20px; font-size: 18px; text-decoration: none; }
    #back-link:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>🐍 遊戲回放</h1>
  <p id="replay-status">載入中...</p>
  <canvas id="game" width="400" height="400"></canvas>
  <input type="range" id="progress-slider" value="0" step="1">
  <div id="controls">
    <div class="btn" id="restart-btn">⏮️ 重頭</div>
    <div class="btn" id="play-pause-btn">▶️ 播放</div>
    <div id="frame-counter">0 / 0</div>
  </div>
  <a id="back-link" href="index.html">返回遊戲</a>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAtkZyxuP2alDTUm1AA7EAlPYSvvZAznEI",
      authDomain: "cogent-altar-468009-p7.firebaseapp.com",
      projectId: "cogent-altar-468009-p7",
      storageBucket: "cogent-altar-468009-p7.firebasestorage.app",
      messagingSenderId: "849610525376",
      appId: "1:849610525376:web:154b5103d027710734fb25"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusText = document.getElementById("replay-status");
    const playPauseBtn = document.getElementById("play-pause-btn");
    const restartBtn = document.getElementById("restart-btn");
    const progressSlider = document.getElementById("progress-slider");
    const frameCounter = document.getElementById("frame-counter");

    const gridSize = 20;
    const tileCount = canvas.width / gridSize;

    // --- 【修改 1】變數用途不變，但資料來源改變了 ---
    let replayData = []; // 依然用來儲存所有幀，但現在需要動態生成
    let currentFrameIndex = 0;
    let isPlaying = false;
    let playbackInterval;

    function drawFrame(index) {
      const frame = replayData[index];
      if (!frame) return;
      currentFrameIndex = index;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "red";
      ctx.fillRect(frame.apple.x * gridSize, frame.apple.y * gridSize, gridSize, gridSize);
      ctx.fillStyle = "lime";
      for (let s of frame.snake) {
        ctx.fillRect(s.x * gridSize, s.y * gridSize, gridSize - 1, gridSize - 1);
      }
      ctx.fillStyle = "white";
      ctx.font = "16px sans-serif";
      ctx.fillText("分數：" + frame.score, 10, 390);

      progressSlider.value = index;
      frameCounter.textContent = `${index + 1} / ${replayData.length}`;
    }

    function togglePlayPause() { isPlaying ? pause() : play(); }
    function play() {
      if (currentFrameIndex >= replayData.length - 1) return;
      isPlaying = true;
      playPauseBtn.textContent = "⏸️ 暫停";
      playbackInterval = setInterval(() => {
        if (currentFrameIndex < replayData.length - 1) {
          drawFrame(currentFrameIndex + 1);
        } else {
          pause();
        }
      }, 150);
    }
    function pause() {
      isPlaying = false;
      playPauseBtn.textContent = "▶️ 播放";
      clearInterval(playbackInterval);
    }
    function restart() {
      pause();
      drawFrame(0);
    }

    // --- 【修改 2】重寫整個遊戲回放模擬器 ---
    // 這個函式會根據初始狀態和帶有時間戳的操作指令，精確地重新計算出遊戲的每一幀
    function generateFramesFromHistory(initialState, moves) {
      let snake = JSON.parse(JSON.stringify(initialState.snake));
      let apple = { ...initialState.apple };
      let score = 0;
      let dx = 0, dy = 0; // 初始方向為靜止，等待第一個指令
      let frameCount = 0;
      let moveIndex = 0;
      const generatedFrames = [];

      // 遊戲開始時，如果沒有立即的操作，預設一個初始方向 (例如向右)
      // 這確保了即使第一個指令在好幾幀之後，蛇也會從一開始就移動
      if (moves.length > 0 && moves[0].frame > 0) {
        dx = 1; dy = 0;
      }

      while (true) {
        // 檢查當前幀是否有對應的操作
        if (moveIndex < moves.length && moves[moveIndex].frame === frameCount) {
          const move = moves[moveIndex].move;
          if (move === 'u' && dy === 0) { dx = 0; dy = -1; }
          else if (move === 'd' && dy === 0) { dx = 0; dy = 1; }
          else if (move === 'l' && dx === 0) { dx = -1; dy = 0; }
          else if (move === 'r' && dx === 0) { dx = 1; dy = 0; }
          moveIndex++;
        }

        // --- 以下是與 index.html 中 gameLoop 完全一致的遊戲邏輯 ---

        // 保存當前幀的狀態 (在移動之前保存)
        generatedFrames.push({
          snake: JSON.parse(JSON.stringify(snake)),
          apple: { ...apple },
          score: score
        });

        // 如果遊戲還沒收到第一個指令，蛇保持不動
        if (dx === 0 && dy === 0 && frameCount < (moves.length > 0 ? moves[0].frame : Infinity)) {
            frameCount++;
            continue;
        }

        // 計算下一步
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || snake.some(s => s.x === head.x && s.y === head.y)) {
          break; // 撞牆或撞自己，模擬結束
        }

        snake.unshift(head);

        if (head.x === apple.x && head.y === apple.y) {
          score++;
          //【重要】蘋果生成邏輯必須與 index.html 完全一致
          let newX, newY;
          do {
            newX = (snake[0].x * 3 + snake[1].x * 5 + score) % tileCount;
            newY = (snake[0].y * 7 + snake[1].y * 2 + score) % tileCount;
            apple = { x: newX, y: newY };
          } while (snake.some(s => s.x === apple.x && s.y === apple.y));

        } else {
          snake.pop();
        }

        frameCount++; // 推進時間
      }
      return generatedFrames;
    }

    async function initializeReplay() {
      const urlParams = new URLSearchParams(window.location.search);
      const replayId = urlParams.get('id');

      if (!replayId) {
        statusText.textContent = "錯誤：URL 中找不到回放 ID。";
        return;
      }

      try {
        statusText.textContent = "正在從 Firebase 讀取紀錄...";
        const doc = await db.collection("replays").doc(replayId).get();

        if (doc.exists) {
          const data = doc.data();
          statusText.textContent = "正在產生回放畫面...";

          // --- 【修改 3】呼叫新的模擬器來生成 replayData ---
          replayData = generateFramesFromHistory(data.initialState, data.moves);

          if (replayData.length === 0) {
              statusText.textContent = "錯誤：無法生成回放資料，可能是紀錄有問題。";
              return;
          }

          statusText.textContent = `成功載入！最終分數：${data.finalScore}`;
          progressSlider.max = replayData.length - 1;
          drawFrame(0);

          playPauseBtn.addEventListener("click", togglePlayPause);
          restartBtn.addEventListener("click", restart);
          progressSlider.addEventListener("input", (e) => {
              pause();
              drawFrame(parseInt(e.target.value));
          });
        } else {
          statusText.textContent = "錯誤：在資料庫中找不到這個回放紀錄。";
        }
      } catch (error) {
        console.error("Error fetching replay: ", error);
        statusText.textContent = "讀取紀錄失敗，請檢查主控台錯誤訊息。";
      }
    }

    initializeReplay();
  </script>
</body>
</html>